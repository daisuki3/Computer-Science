#include <iostream>
using namespace std;

void InsertionSort(int *A, int n) {                  // 升序排序
	int j, p;

	for (p = 1; p < n; p++) {
		int tmp = A[p];
		for (j = p; j > 0 && A[j - 1] > tmp; j--)  //比A.p大的元素都被右移 直到寻找到合适的位置
			A[j] = A[j - 1];
		A[j] = tmp;  
	}
}


void ShellSort(int *A,int n) {
	int i, j, incre;

	for(incre=n/2;incre>0;incre/=2)
		for (i = incre; i < n; i++) {
			int tmp = A[i];
			for (j = i; j >= incre && A[j - incre] > tmp; j -= incre) 
				A[j] = A[j - incre];
			A[j] = tmp;
		}
}


void Msort(int *A, int *tmp, int left, int right);
void Merge(int *A, int *tmp, int left, int right, int rightend);

void MergeSort(int *A, int n) {
	int *tmp = new int[n];
	if (tmp != NULL) {
		Msort(A, tmp, 0, n - 1);
		delete []tmp;
	}
}

void Msort(int *A, int *tmp, int left, int right) {
	if (left < right) {
		int center = left + (right - left) / 2;
		Msort(A, tmp, left, center);
		Msort(A, tmp, center + 1, right);
		Merge(A, tmp, left, center + 1, right);
	}
}

void Merge(int *A, int *tmp, int left, int right, int rightend) {
	int  leftend, num, tmppos;

	leftend = right - 1;
	tmppos = left;
	num = rightend - left + 1;

	while (left <= leftend && right <= rightend) 
		if (A[left] <= A[right])
			tmp[tmppos++] = A[left++];
		else
			tmp[tmppos++] = A[right++];

	while (left <= leftend)
		tmp[tmppos++] = A[left++];
	while (right <= rightend)
		tmp[tmppos++] = A[right++];
	
	for (int i = 0; i < num; i++)
		A[rightend] = tmp[rightend--];
}

#define cutoff (5)

void Qsort(int *, int, int);
int Median3(int *, int, int);

void Swap(int *a, int *b) {
	int tmp = *a;
	*a =*b;
	*b = tmp;
}
void QuickSort(int *A, int n) {
	Qsort(A, 0, n - 1);
}
void Qsort(int *A, int left, int right) {
	if (left + cutoff <= right) {
		int pivot = Median3(A, left, right);
		int i = left, j = right - 1;
		while (1) {
			while (A[++i] < A[pivot]);
			while (A[--j] > A[pivot]);

			if (i < j)
				Swap(&A[i], &A[j]);
			else
				break;
		}
		Swap(&A[i], &A[right - 1]);

		Qsort(A, 0, i - 1);
		Qsort(A, i + 1, right);
	}
	else
		InsertionSort(A + left, right - left + 1);
}

int Median3(int *A, int left, int right) {
	int center = (left + right) / 2;

	if (A[left] > A[center])
		Swap(&A[left], &A[center]);
	if (A[left] > A[right])
		Swap(&A[left], &A[right]);
	if (A[center] > A[right])
		Swap(&A[center], &A[right]);
	// right <= center<= right

	Swap(&A[center], &A[right - 1]);
	return A[right - 1];
}

void percUp(int *a,int n){
	if(n==1) return;
	for(int i=(n-1-1)/2;i>=0;--i){
		int child=2*i+1;
		if(child+1<n && a[child+1]>a[child])
			++child;
		if(a[i]<a[child])
			Swap(&a[i],&a[child]);
	}
}

void HeapSort(int *a,int n){
	percUp(a,n);

	for(int j=n;j>1;--j){
		Swap(&a[0],&a[j-1]);
		percUp(a,j-1);
	}
}

void PrintArray(int *A,int n) {
	for (int i = 0; i < n; i++) {
		cout << A[i]<<" ";
	}
	cout << endl;
}

int main() {
	int A[] = { 8,6,9,4,3};
	QuickSort(A, 5);
	PrintArray(A, 5);

	return 0;
}
