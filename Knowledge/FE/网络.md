# cookie 和 session  
cookie是保存在客户端的用户数据
session是放在服务端用来跟踪用户状态的信息

# TCP  
TCP报文格式
1. 源端口 目的端口
2. 序列号
3. 确认号
4. 数据偏移（表示TCP首部的长度） 保留位 控制位 窗口大小


- 流量控制
通过滑动窗口实现，作用在数据接收方，防止对方发送数据过快，发送方根据接受方的处理能力来发送数据。

- 拥塞控制
    - 快恢复
        拥塞后，阙值ssthresh赋值为窗口大小，窗口大小减半，进入拥塞避免。
        作用，避免因为一次意外拥塞就进入效率低的慢启动。
    - 慢启动
        收到一个ack后cwnd+1，一个RTT翻倍，达到阙值后进入拥塞避免。
        慢启动其实增加的速度并不慢，只是起点很低，0，这才是它名称的由来。
    - 加法增加乘法减少，拥塞避免
        拥塞窗口线性增加，发生超时后则积式（对半）减少

- 三次握手
    
    1. 第一次握手 A端发送 SYN(synchronize sequence number)
    2. 第二次握手 B端发送 SYN/ACK，A端收到后，知道自己的发送和接收能力正常。但B端只知道自己的接收能力正常  
    3. 第三次握手 A端发送 ACK，B端收到后，知道自己的发送能力正常。连接建立。  

第一二次握手不可以携带数据。防止对服务器的恶意攻击。攻击者在一次握手的报文中放入大量数据，可以使服务器花费很多时间和内存来处理这些报文。  

**发送第一个包时，SYN号随机**
1 防止连接重新建立后数据冲突 
2 防止TCP序号预测攻击， 如果攻击者能猜到服务器的初始序列号，就能假冒对第二次握手的回答，从而建立连接，进入服务器。


重传 
- 重复累计确认
    重复确认是包丢失的信号。收到3次同一个包的确认，重传最后一个未被确认的包，即重复确认的包后面的那一个包。
- 超时重传
    重传定时器超时后重传。
    如果定时器被触发，它的时间翻倍（直到一个阙值），这可以避免服务器在遭受DOS攻击时，客户端还一直重传，雪上加霜。


序号SYN是本包的序列 
确认号ACK是对来包的回应，来包SYN + 1

SYN队列 存放完成了二次握手的
ACCEPT队列 存放完成了三次握手的

    - SYN攻击  
第一次握手时，攻击者伪造不存在的ip地址，服务器第二次握手后，等待client的第三次握手，不断重发，占用服务器资源。

- **四次挥手**
    1. A端发送FIN报文 FIN置1
    2. B端发送ACK报文 ACK置1

    3. B端发送FIN报文 FIN置1
    4. A端发送ACK报文 ACK置1

2和3不能融合。在2时，B端可能**尚且存在需要向A端发送的报文**，等待这些报文处理完毕，才能进入3。

4之后，A不能立即关闭，需要等待2MSL（maximum segment lifetime）再关闭。
理由：
1. 防止因为最后一个ACK丢失而导致服务器无法正常进入关闭连接状态.
2. 使本连接中的所有报文都从网络中消失，新连接中不会出现旧连接的报文。



# osi

1. 
2. 
3. 
4. 
5. 会话层
6. 表达层
7. 应用层



# HTTP

1. 支持客户端/服务器模式。

2. 无连接
处理完客户的请求并收到应答后立即断开连接。

3. 无状态
不需要验证对方的状态。
对于事务处理没有记忆能力，如果后续需要前面的信息必须重传。



## 发展历程

TCP连接对http的效率影响很大
### TCP连接
1. 多个TCP连接(并行连接) 
</br>缺点：如果建立的连接太多，会消耗太多内存资源，使性能严重下降。

2. keep-alive (http/1.0)
</br>缺点: 如果空闲的连接太多，会严重影响服务器性能。

3. 持久连接 (http/1.1)
</br> 默认使用keep-alive

4. 管道化 (http/1.1)

建立在持久连接的基础之上，不必等请求返回再发送新的请求。
但是返回时必须按照请求的顺序，**顺序不能乱**，这就存在队头阻塞。


5. 多路复用 (http/2.0)

解决了**http层的队头阻塞**

头部压缩 HPACK算法
头部排序
编解码上下文,即静态表和动态表（双端各自维护，且上下文有关，每个HTTP连接不同）被组合到索引地址空间中
对表的索引和字面头部可以混用，字面头部可以用静态哈夫曼编码。

一个域名只有一个TCP连接。

弃用了文本格式的传输，基于二进制数据帧，解析数据更快。

每个请求被拆分成frame 帧，不同请求的frame可以自由组合成stream 流，因为帧中有streamid的存在，可以在到达后将切割的信息还原。

stream是TCP连接上的逻辑传输单元。

每个请求被拆分成多个frame通过一条TCP连接同时被传输，这样即使一个请求被阻塞也不会影响其他的请求。


缺点：
- 多路复用虽然解决了“请求”这个粒度的阻塞，但是TCP协议有严格的先后顺序，协议本身存在队头阻塞。
- http/2必须使用https，TLS协议存在队头阻塞。TLS基于Record组织数据，一堆数据放在一起加密，然后拆分成多个TCP包发送，任何一个包丢失都会导致Record无法解密。

随着版本迭代，不断地减少多次创建tcp带来的性能损耗


服务端推送 
发送比请求更多的资源，而不是等到加载解析时收到请求再发送，提高解析速度

正向代理 
客户端的代理 服务器只知道代理的IP
反向代理
服务器的代理 客户端只知道代理的IP

CDN 内容分发网络 
利用最靠近或者说是最方便的服务器欸用户提供资源。
若服务器本身带宽，放置服务器到多个地点，可以提升系统总的带宽。


### QUIC(quick udp internet conection)协议
基于UDP的http协议

**优点**
- QUIC的传输单元和加密单元都是Packet，避免了TLS阻塞。
- UDP包没有处理顺序，包的丢失不会阻塞整条队列。

#### QUIC拥塞控制
- 慢启动
指数增长
- 拥塞避免
线性增长
- 快速重传
超时重发
- 快速恢复
超时即进入拥塞避免，再超时则进入慢启动

- FEC(forward error correction)
数据切分成的包进行异或计算得到的FEC包和切分成的包一起传输，在只丢失一个数据包的情况下可以用FEC包来恢复数据。

- 单调递增的Packet number，避免了RTT的计算错误。


# HTTPS

## 安全性保证

HTTPS 建立在SSL/TLS之上。
（区别？SSL存在缺陷，已被弃用，强制使用TLS）

- 数据完整性

- 内容加密

- 身份认证

使用非对称加密+对称加密进行数据安全性保证。

非对称加密 公钥加密 私钥解密
对称加密 加密解密使用同一个密钥

1. 客户端获取服务器的证书（包含公钥A）
2. 客户端用公钥A加密私钥B传输给服务器

3. 服务器用私钥A解密公钥A获取私钥B
4. 双方用私钥B加密解密数据

服务器的公钥：作用是通信前的密钥确认
客户端的私钥：通信用的密钥

- 潜在危险：中间人伪造公钥

    1. 中间人劫持服务器传输的公钥A，再传输自己的公钥K给客户端
    2. 之后再劫持客户端用公钥K加密的私钥B，可以得到客户端的私钥B
    3. 再用公钥A的算法（**客户端公钥A是公开的**）加密私钥B传给服务器。
</br>这样中间人就在双方不知情的情况下取得了私钥B。

解决方法：网站**数字证书**。用数字证书传输公钥。

证书真伪验证：**数字签名**。

- 证书篡改风险解决方案

    1. 服务器hash证书得到消息摘要，再用CA机构给自己的**专属私钥**加密**消息摘要**得到**数字签名**。

    2. 客户端用**服务器公钥**解密数字签名得到消息摘要A，客户端hash证书得到消息摘要B，如果**A和B相等**则代表证书来自服务器，没有被篡改。

    关键在于专属私钥得到数字签名，和服务器公钥解密数字签名。

- 证书替换
不存在这种风险，可本地对比客户端请求域名和证书域名

# TCP VS UDP

TCP 包头最小长度 20字节 基于连接 
UDP 包头 8字节 基于报文

TCP 流模式
UDP 数据报模式

TCP 可靠
UDP不保证可靠性 不需要维持复杂的链接状态表


UDP不保证顺序 
TCP ACK置1表示（SYN之前的数据都收到了）

# ICMP
internet control message protocol
网络控制报文协议

主机、路由器直接传递控制信息
传达的消息是网络通不通，主机是否可达，路由是否可用
