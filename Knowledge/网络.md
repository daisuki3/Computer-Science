# cookie 和 session  
cookie是保存在客户端的用户数据
session是放在服务端用来跟踪用户状态的信息

# TCP  
TCP报文格式
1. 源端口 目的端口
2. 序列号
3. 确认号
4. 数据偏移（表示TCP首部的长度） 保留位 控制位 窗口大小


- 流量控制
通过滑动窗口实现，作用在数据接收方，防止对方发送数据过快，发送方根据接受方的处理能力来发送数据。

- 拥塞控制
    - 快恢复
        拥塞后，阙值ssthresh赋值为窗口大小，窗口大小减半，进入拥塞避免。
        作用，避免因为一次意外拥塞就进入效率低的慢启动。
    - 慢启动
        收到一个ack后cwnd+1，一个RTT翻倍，达到阙值后进入拥塞避免。
    - 加法增加乘法减少，拥塞避免
        拥塞窗口线性增加，发生超时后则积式（对半）减少

- 三次握手

第一次握手 A端发送TCP报文
第二次握手 B端发送TCP报文，A端收到后，知道自己的发送和接收能力正常。但B端只知道自己的接收能力正常  
第三次握手 A端发送TCP报文，B端收到后，知道自己的发送能力正常。连接建立。  

第一二次握手不可以携带数据。防止对服务器的恶意攻击。攻击者在一次握手的报文中放入大量数据，可以使服务器花费很多时间和内存来处理这些报文。  

- 半连接队列  
服务器收到第一次握手的报文后，双方还没有建立完全的连接，把这种状态的客户端放在一个半连接队列里。  
已经完成三次握手的客户端放在全连接队列里。

- SYN攻击  
第一次握手时，攻击者伪造不存在的ip地址，服务器第二次握手后，等待client的第三次握手，不断重发，占用服务器资源。

- 四次挥手
1.A端发送FIN报文
2.B端发送ACK报文
3.B端发送FIN报文
4.A端发送ACK报文  

2和3不能融合。在2时，B端可能尚且存在需要向A端发送的报文，等待这些报文处理完毕，才能进入3。
4之后，A不能立即关闭，需要等待2MSL（maximum segment lifetime）再关闭。
理由：
1. 防止因为最后一个ACK丢失而导致服务器无法正常进入关闭连接状态.
2. 使本连接中的所有报文都从网络中消失，新连接中不会出现旧连接的报文。



# osi

1. 
2. 
3. 
4. 
5. 会话层
6. 表达层
7. 应用层



# HTTP

1. 支持客户端/服务器模式。

2. 无连接
处理完客户的请求并收到应答后立即断开连接。

3. 无状态
不需要验证对方的状态。
对于事务处理没有记忆能力，如果后续需要前面的信息必须重传。

## 发展历程

TCP连接对http的效率影响很大
### TCP连接
1. 多个TCP连接(并行连接) 
</br>缺点：如果建立的连接太多，会消耗太多内存资源，使性能严重下降。

2. keep-alive (http/1.0)
</br>缺点: 如果空闲的连接太多，会严重影响服务器性能。

3. 持久连接 (http/1.1)
</br> 默认使用keep-alive

4. 管道化 (http/1.1)

</br>建立在持久连接的基础之上，不必等请求返回再发送新的请求。
</br>缺点：
1. 服务器执行顺序影响结果时可能产生问题.
2. 无法定位会产生副作用的请求

5. 多路复用 (http/2.0)
</br>弃用了文本格式的传输，基于二进制数据帧，可以做到乱序的传输。
</br>每个请求被拆分成frame，不同请求的frame组合成stream，stream是TCP连接上的逻辑传输单元。
</br>每个请求被拆分成多个frame通过一条TCP连接同时被传输，这样即使一个请求被阻塞也不会影响其他的请求。
</br>缺点：
- 多路复用虽然解决了“请求”这个粒度的阻塞，但是TCP协议有严格的先后顺序，协议本身存在队头阻塞。
- http/2必须使用https，TLS协议存在队头阻塞。TLS基于Record组织数据，一堆数据放在一起加密，然后拆分成多个TCP包发送，任何一个包丢失都会导致Record无法解密。

随着版本迭代，不断地减少多次创建tcp带来的性能损耗

### QUIC(quick udp internet conection)协议
基于UDP的http协议

**优点**
- QUIC的传输单元和加密单元都是Packet，避免了TLS阻塞。
- UDP包没有处理顺序，包的丢失不会阻塞整条队列。

#### QUIC拥塞控制
- 慢启动
指数增长
- 拥塞避免
线性增长
- 快速重传
超时重发
- 快速恢复
超时即进入拥塞避免，再超时则进入慢启动

- FEC(forward error correction)
数据切分成的包进行异或计算得到的FEC包和切分成的包一起传输，在只丢失一个数据包的情况下可以用FEC包来恢复数据。

- 单调递增的Packet number，避免了RTT的计算错误。


# HTTPS

## 安全性保证

HTTPS 建立在SSL/TLS之上。

- 数据完整性

- 内容加密

- 身份认证

使用非对称加密+对称加密进行数据安全性保证。

1. 客户端获取服务器的证书（包含公钥A）
2. 客户端用公钥A加密私钥B传输给服务器
3. 服务器用私钥A解密公钥A获取私钥B
4. 双方用私钥B加密解密数据

- 潜在危险：中间人伪造公钥

    1. 中间人劫持服务器传输的公钥A，再传输自己的公钥K给客户端
    2. 之后再劫持客户端用公钥K加密的私钥B，可以得到客户端的私钥B
    3. 再用公钥A的算法加密私钥B传给服务器。
</br>这样中间人就在双方不知情的情况下取得了私钥B。

解决方法：网站**数字证书**。用数字证书传输公钥。

证书真伪验证：**数字签名**。

- 证书篡改风险解决方案

    1. 服务器hash证书得到消息摘要，再用CA机构给自己的**专属私钥**加密**消息摘要**得到**数字签名**。

    2. 客户端用**服务器公钥**解密数字签名得到消息摘要A，客户端hash证书得到消息摘要B，如果**A和B相等**则代表证书来自服务器，没有被篡改。

- 证书替换
不存在这种风险，可本地对比客户端请求域名和证书域名