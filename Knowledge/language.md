# 内存泄漏  
动态分配的堆内存由于某些原因未释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。  

- 源代码插装  
源代码插装测试必须在静态测试部分获得的被测程序的结构信息、静态数据信息、控制流信息等基础上，应用插装技术向被测程序中的适当位置植入相应类型的探针，通过运行带有探针的被测程序而获得程序运行的动态数据。源代码插装要通过运行被测程序来测定程序的各种指标，如覆盖率、时间性能、内存使用等等。  
实现源代码插装的关键技术是借助于**插入到源程序中的监控语句来收集执行信息**，以达到揭示程序内部行为和特性的目的。



# 虚函数
基类**声明**虚函数

作用：允许通过基类的指针来调用派生类的函数  
实现方式：函数表   

纯虚函数声明 virtual void func() = 0;  
拥有纯虚函数的类为抽象类。抽象类不能定义对象。  
抽象类的派生类必须具体地实现其基类的纯虚函数，否则派生类也是抽象类。

## 虚析构函数
作用：用基类的指针删除派生类的对象

删除顺序；自下而上 派生类 - 基类

## 虚基类

作用；消除多重继承下的歧义

声明基类为虚基类，在构造最远派生类对象时，只生成一个基类对象。

```cpp
class A0{
    //code
    }

class A1:virtual public A0{
    //code
    }

class A2:virtual public A0{//code
}

class A3:public A1,public A2{//code
}
```

**需要在最远派生类的构造函数中调用基类的构造函数**
```cpp
A3::A3():A0(),A1(),A2(){
    //code
    }
```

# 友元

```cpp
class E{
    //code
friend void func() 
//类E的友元函数
friend class A;
//类E的友元类A，A的成员函数都是E的友元函数
}
``` 

友元函数不是成员函数，但可以访问类中的**私有成员**。  



# 拷贝构造函数

## 调用时机
1. 一个对象以值传递的方式作为函数参数  
2. 一个对象以值传递的方式作为函数返回值  
3. 一个对象用以给另一个对象初始化
## 原因，为什么要使用拷贝构造函数
如果对象中有指针，这时在以上三种情况调用普通的构造方法，  
会使两个指针指向同一块内存。  

``` c++
class Example(){
    Example(const Example& old){
        //code
    }
}
```  
**必须传引用，传值会再次调用拷贝构造函数，无限循环直到栈溢出。**



# 继承

## 子类重写方法的访问权限不能低于父类中访问权限

原因：
class B extends A
```java
void get(A a){
    a.func();
}
```

向get函数传入B类对象，如果B类的func访问权限更严格，可能产生错误。

## 子类重写方法的返回类型必须与父类相同或者是父类返回类型的子类

根本原因与访问权限的限制相同，因为**向上转型**。