# 数据库范式

## 1NF
数据库表中每一列都是不可分割的基本数据项
**某个属性不能有多个值**

## 2NF
表中其他元素都必须**完全依赖于主键**

属性集C只依赖于**主键的一部分**，可能造成属性集C的数据冗余。那么它不符合2NF


## 3NF

前提：满足2NF
3NF是2NF的子集

表中属性集C依赖于非主键属性可能造成属性集C数据冗余。

不存在上述现象即符合3NF
即不存在**依赖传递**  
任何非主属性不得传递依赖于主属性

## BCNF  

3NF的基础上

**3NF消除了主键外的传递依赖，但没有消除涉及主键的传递依赖**

BCNF:**每个非平凡FD(Function Dependency)的左边都必须是超键** 
即任何非主属性不能依赖于**主键的子集**
非平凡FD：X -> Y, 其中Y不是X的子集  
**超键**： 唯一标识元组的属性集



### 异常
1. 冗余
2. 更新异常
信息不一致
3. 删除异常
信息丢失

### 分解
将一个包含异常的关系分解成多个不包含异常的关系
分解算法：
输入：R0和函数依赖集S0
输出：R0分解出的属于BCNF的子集

规定每个关系的全属性集 = T

1. 检查R是否属于BCNF，是就返回R
2. 违例X->Y,计算X<sup>+</sup>,R1=X<sup>+</sup>,R2=T-X<sup>
+</sup>
3. 计算R1和R2的最小函数依赖集
4. 用本算法递归分解R1和R2

2中计算X的闭包X<sup>+</sup>的原因,为了R1的数据一致性和完整性

# 锁

## 乐观锁
读取数据后，乐观地认为数据不会再改变。任何其他进程都可以读取数据。

实现方式：

1. 版本号
</br>给数据库加版本号“version”字段，之后更新时，比对版本信息，如果版本信息一致，则更新，不一致，则认为是过期的数据。

2. CAS(compare and swap)算法
</br>读取数据时同时储存旧值a，地址v。
</br>写入新数据b时，如果地址v处的数据值为a，才将地址v处的数据替换为b。
</br>缺点：ABA问题
解决方法：为变量值A加版本号


适用场景：多读，少写

## 悲观锁

每次读数据都会上锁，共享资源只给一个线程使用。

缺点：

1. 效率低

使用场景：少读，多写